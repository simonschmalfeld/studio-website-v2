---
// Astro component version
---

<canvas id='triangle-canvas' class='triangle-background'></canvas>

<style>
  .triangle-background {
    position: fixed;
    top: 0;
    left: 0;
    z-index: -1;
    width: 100vw;
    height: 100vh;
    pointer-events: none;
  }
</style>

<script>
  interface Triangle {
    x: number
    y: number
    size: number
    rotation: number
    opacity: number
    speed: number
    parallaxSpeed: number
    originalY: number
  }

  class TriangleBackground {
    private canvas: HTMLCanvasElement
    private ctx: CanvasRenderingContext2D
    private triangles: Triangle[] = []
    private mouse = { x: 0, y: 0 }
    private scrollY = 0
    private animationId: number | null = null

    constructor(canvas: HTMLCanvasElement) {
      this.canvas = canvas
      this.ctx = canvas.getContext('2d')!

      this.init()
      this.setupEventListeners()
      this.animate()
    }

    private init() {
      this.resize()
      this.initTriangles()
    }

    private resize() {
      this.canvas.width = window.innerWidth
      this.canvas.height = window.innerHeight
      // Reinitialize triangles to account for new canvas size
      this.initTriangles()
    }

    private initTriangles() {
      this.triangles = []
      const triangleCount = Math.floor((this.canvas.width * this.canvas.height) / 15000)

      for (let i = 0; i < triangleCount; i++) {
        const y = Math.random() * this.canvas.height
        this.triangles.push({
          x: Math.random() * this.canvas.width,
          y: y,
          originalY: y,
          size: Math.random() * 20 + 10,
          rotation: Math.random() * 360,
          opacity: Math.random() * 0.3 + 0.1,
          speed: Math.random() * 0.5 + 0.2,
          parallaxSpeed: Math.random() * 0.3 + 0.1, // Different parallax speeds for layered effect
        })
      }
    }

    private drawTriangle(triangle: Triangle) {
      this.ctx.save()
      this.ctx.translate(triangle.x, triangle.y)
      this.ctx.rotate((triangle.rotation * Math.PI) / 180)
      this.ctx.globalAlpha = triangle.opacity

      this.ctx.beginPath()
      this.ctx.moveTo(0, -triangle.size / 2)
      this.ctx.lineTo(-triangle.size / 2, triangle.size / 2)
      this.ctx.lineTo(triangle.size / 2, triangle.size / 2)
      this.ctx.closePath()

      const gradient = this.ctx.createLinearGradient(
        -triangle.size / 2,
        -triangle.size / 2,
        triangle.size / 2,
        triangle.size / 2
      )
      gradient.addColorStop(0, '#3b82f6')
      gradient.addColorStop(0.5, '#8b5cf6')
      gradient.addColorStop(1, '#06b6d4')

      this.ctx.fillStyle = gradient
      this.ctx.fill()

      this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'
      this.ctx.lineWidth = 1
      this.ctx.stroke()

      this.ctx.restore()
    }

    private animate = () => {
      // Clear canvas with gradient background
      const gradient = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height)
      gradient.addColorStop(0, '#0f172a')
      gradient.addColorStop(0.5, '#1e293b')
      gradient.addColorStop(1, '#334155')

      this.ctx.fillStyle = gradient
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height)

      // Update and draw triangles
      this.triangles.forEach((triangle) => {
        // Apply parallax effect based on scroll position (negative for upward movement)
        triangle.y = triangle.originalY - this.scrollY * triangle.parallaxSpeed

        const dx = this.mouse.x - triangle.x
        const dy = this.mouse.y - triangle.y
        const distance = Math.sqrt(dx * dx + dy * dy)
        const maxDistance = 200

        if (distance < maxDistance) {
          const influence = (maxDistance - distance) / maxDistance
          triangle.x += (dx / distance) * influence * 2
          // Reduce Y movement when parallax is active to prevent conflicts
          triangle.y += (dy / distance) * influence * 1
          triangle.rotation += influence * 3
          triangle.opacity = Math.min(0.8, triangle.opacity + influence * 0.3)
        } else {
          triangle.opacity = Math.max(0.1, triangle.opacity - 0.01)
          triangle.rotation += triangle.speed
        }

        // Wrap around edges with parallax consideration
        if (triangle.x < -50) triangle.x = this.canvas.width + 50
        if (triangle.x > this.canvas.width + 50) triangle.x = -50

        // For Y wrapping, consider the parallax offset
        const parallaxOffset = -this.scrollY * triangle.parallaxSpeed
        if (triangle.y < -50 + parallaxOffset) {
          triangle.originalY = this.canvas.height + 50
          triangle.y = triangle.originalY + parallaxOffset
        }
        if (triangle.y > this.canvas.height + 50 + parallaxOffset) {
          triangle.originalY = -50
          triangle.y = triangle.originalY + parallaxOffset
        }

        this.drawTriangle(triangle)
      })

      this.animationId = requestAnimationFrame(this.animate)
    }

    private setupEventListeners() {
      window.addEventListener('resize', () => this.resize())

      window.addEventListener('mousemove', (event) => {
        const rect = this.canvas.getBoundingClientRect()
        this.mouse.x = event.clientX - rect.left
        this.mouse.y = event.clientY - rect.top
      })

      // Add scroll event listener for parallax effect
      window.addEventListener('scroll', () => {
        this.scrollY = window.scrollY
      })

      // Initialize scroll position
      this.scrollY = window.scrollY
    }

    public destroy() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId)
      }
    }
  }

  // Initialize when DOM is loaded
  document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('triangle-canvas') as HTMLCanvasElement
    if (canvas) {
      new TriangleBackground(canvas)
    }
  })
</script>
